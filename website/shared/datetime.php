<?php
class IllaDateTime {
	/**
	* Get the name of a month
	* The month index starts at 1
	*
	* @access public
	* @param int $month_nr The number of the month
	* @return string
	*/
	static public function getMonthName($month_nr) {
		switch ($month_nr) {
			case 1: return 'Elos';
			case 2: return 'Tanos';
			case 3: return 'Zhas';
			case 4: return 'Ushos';
			case 5: return 'Siros';
			case 6: return 'Ronas';
			case 7: return 'Bras';
			case 8: return 'Eldas';
			case 9: return 'Irmas';
			case 10: return 'Malas';
			case 11: return 'Findos';
			case 12: return 'Olos';
			case 13: return 'Adras';
			case 14: return 'Naras';
			case 15: return 'Chos';
			case 16: return 'Mas';
			default: return 'Unknown Month ' . $month_nr;
		}
	}

	/**
	* Get the description of a month
	* The month index starts at 1
	*
	* @access public
	* @param int $month_nr The number of the month
	* @return string
	*/
	static public function getMonthDescription($month_nr) {
		switch ($month_nr) {
			case 1: return (Page::isGerman() ? 'Monat der Magie' : 'Month of Magic'); // Elos
			case 2: return (Page::isGerman() ? 'Monat der Fluten' : 'Month of Floods'); // Tanos
			case 3: return (Page::isGerman() ? 'Monat der Treue' : 'Month of Loyalty'); // Zhas
			case 4: return (Page::isGerman() ? 'Monat der Aussaat' : 'Month of Sowing'); // Ushos
			case 5: return (Page::isGerman() ? 'Monat der Liebe' : 'Month of Love'); // Siros
			case 6: return (Page::isGerman() ? 'Monat der Freigiebigkeit' : 'Month of Generosity'); // Ronas
			case 7: return (Page::isGerman() ? 'Monat der Opferung' : 'Month of Immolation'); // Bras
			case 8: return (Page::isGerman() ? 'Monat des Fastens' : 'Month of Abstinence'); // Eldas
			case 9: return (Page::isGerman() ? 'Monat des Handwerks' : 'Month of Trade'); // Irmas
			case 10: return (Page::isGerman() ? 'Monat des Jägers' : 'Month of the Hunter'); // Malas
			case 11: return (Page::isGerman() ? 'Monat der bildenden Künste' : 'Month of Fine Arts'); // Findos
			case 12: return (Page::isGerman() ? 'Monat der Ernte' : 'Month of Harvest'); // Olos
			case 13: return (Page::isGerman() ? 'Monat der Trunkenheit' : 'Month of Intoxication'); // Adras
			case 14: return (Page::isGerman() ? 'Monat der vier Winde' : 'Month of the Four Winds'); // Naras
			case 15: return (Page::isGerman() ? 'Monat des Gedenkens' : 'Month of Commemoration'); // Chos
			case 16: return (Page::isGerman() ? 'Monat des Blutes' : 'Month of Blood'); // Mas
			default: return 'Unknown Month ' . $month_nr;
		}
	}

	/**
	* Convert a timestamp with the server offset to the timestamp with the offset
	* of the current user
	* All times generated by the server or stored in the database that shall be shown to
	* the User should be converted with this function
	* In case the parameter is not set the current timestamp is used
	*
	* @access public
	* @param int $timestamp the timestamp that shall converted
	* @return int
	*/
	static public function TimestampWithOffset($timestamp = false) {
		if ($timestamp === false) {
			$timestamp = time();
		}
		if (!class_exists('IllaUser') || !IllaUser::loggedIn()) {
			return $timestamp;
		}
		$server_offset = (int)(date('O', time())) / 100;
		$new_stamp = floor($timestamp - 3600 * ($server_offset - IllaUser::$time_offset));
		$dst = (int)date('I', $new_stamp);
		if ($dst && IllaUser::$dst) {
			$new_stamp += 3600;
		}
		return $new_stamp;
	}

	/**
	* Convert a timestamp with the offset of the current user to a timestamp with the
	* offset of the server.
	* This should be used for timestamps created from user inputs that shall be stored
	* in the Database.
	* In case the parameter is not set the current timestamp of the server is returned
	*
	* @access public
	* @param int $timestamp the timestamp that shall converted
	* @return int
	*/
	static public function TimestampWithoutOffset($timestamp = false) {
		if ($timestamp === false) {
			return time();
		}
		if (!class_exists('IllaUser') || !IllaUser::loggedIn()) {
			return $timestamp;
		}
		$server_offset = (int)(date('O', time())) / 100;
		$new_stamp = floor($timestamp + 3600 * ($server_offset - IllaUser::$time_offset));
		$dst = (int)date('I', $new_stamp);
		if ($dst && IllaUser::$dst) {
			$new_stamp -= 3600;
		}
		return $new_stamp;
	}

	/**
	* Convert a RL Unix Timestamp to a Illarion Timestamp
	* The resolution of this timestamp is 1 Illarion Second
	* In case the paramter is not set the current server time is used
	*
	* The Illarion 0 Second was at the 17th February 2000 00:00:00
	* The Illarion timestamp is not createable from times before this date
	*
	* IMPORTAINT: The Illarion time is not effected by the RL timezones and so always
	* relative to the timestamp with server offset. Never use this function with a
	* timestamp with user offset
	*
	* @access public
	* @param int $timestamp the timestamp that shall converted
	* @return int
	*/
	static public function RLTimeToIllaTime($timestamp = false) {
		if ($timestamp === false) {
			$timestamp = time();
		}
		return (($timestamp + 3600 * (int)date('I', $timestamp)) - 950742000) * 3;
	}

	/**
	* Convert a Illarion Timestamp of a RL Unix Timestamp with Server offset
	* The resolution of the Illarion Timestamp this function expects is 1 Illarion
	* Second
	* In case the paramter is not set the current RL Unix Timestamp is returned
	*
	* @access public
	* @param int $timestamp the timestamp that shall converted
	* @return int
	*/
	static public function IllaTimeToRLTime($timestamp = false) {
		if ($timestamp === false) {
			return time();
		}
		$rl_time = ($timestamp / 3) + 950742000;
		$rl_time -= 3600 * (int)date('I', $rl_time);
		return $rl_time;
	}

	/**
	* Create a Illarion Timestamp from the hour, the minute, the seconds, the month,
	* the day and the year of a Illarion Time
	* The returned Illarion timestamp has the resolution of 1 second
	*
	* @access public
	* @param int $hour the hour of the date
	* @param int $minute the minute of the date
	* @param int $second the second of the date
	* @param int $month the month of the date
	* @param int $day the day of the date
	* @param int $year the year of the date
	* @return int
	*/
	static public function mkIllaTimestamp($hour = 0, $minute = 0, $second = 0, $month = 1, $day = 1, $year = 0) {
		$time = $second;
		$time += $minute * 60;
		$time += $hour * 3600;
		$time += ($day - 1) * 86400;
		$time += ($month - 1) * 2073600;
		$time += $year * 31536000;
		return $time;
	}

	/**
	* Create a Illarion Datestamp from the month, the day and the year of a Illarion
	* Time
	* The returned Illarion Datestamp as the resolution of 1 day, it can handle dates
	* back to the year -10000
	* In case the variables the function returns the current Illarion Datestamp
	*
	* @access public
	* @param int $month the month of the date
	* @param int $day the day of the date
	* @param int $year the year of the date
	* @return int
	*/
	static public function mkIllaDatestamp($month = 0, $day = 0, $year = 0) {
		if (!$month || !$day) {
			$currvals = self::IllaTimestampToTime('array');
			$month = $currvals['month'];
			$year = $currvals['year'];
			$day = $currvals['day'];
		}
		$illa_day_stamp = ($year + 10000) * 365;
		$illa_day_stamp += ($month - 1) * 24;
		$illa_day_stamp += $day;
		return $illa_day_stamp;
	}

	/**
	* Convert a Illarion Datestamp to a human readable date
	* The function expects a Illarion Datestamp with the resolution of 1 Illarion Day
	* In case the parameter is not set the current day, month and year is returned
	* The return value is a array with 'day', 'month' and 'year' as index
	*
	* @access public
	* @param int $datestamp The Illarion Datestamp
	* @return array
	*/
	static public function IllaDatestampToDate($datestamp = false) {
		if ($datestamp === false) {
			$currvals = self::IllaTimestampToTime('array');
			return array('day' => $currvals['day'], 'month' => $currvals['month'], 'year' => $currvals['year']);
		}
		$year = floor($datestamp / 365);
		$datestamp -= $year * 365;
		$year -= 10000;
		$month = floor($datestamp / 24);
		$datestamp -= $month * 24;
		++$month;
		if (!$datestamp) {
			--$month;
			if (!$month) {
				$datestamp = 5;
			} else {
				$datestamp = 24;
			}
		}
		if (!$month) {
			--$year;
			$month = 16;
		}
		return array('day' => $datestamp, 'month' => $month, 'year' => $year);
	}

	/**
	* Parse a Illarion Timestamp to a specified format. In case the timestamp is not
	* set the current timestamp is used
	* A timestamp with the resolution of 1 second is expected
	*
	* The format string is build up in the same way as the PHP default function 'date'
	* An special string for the format string is 'array'. That returns a array with the
	* numerical values of the day, month, year, hour, minute and second of the timestamp
	*
	* @access public
	* @param string $format The format string
	* @param int $time The Illarion timestamp
	* @return mixed
	*/
	static public function IllaTimestampToTime($format = '', $time = false) {
		if ($format == '') {
			return false;
		}
		if ($time === false) {
			$time = self::RLTimeToIllaTime();
		}

		$copy_time = $time;

		$illa_year = floor($time / 31536000);
		$time -= $illa_year * 31536000;

		$illa_day = floor($time / 86400);
		$time -= $illa_day * 86400;
		++$illa_day;

		$illa_month = floor($illa_day / 24);
		$illa_day -= $illa_month * 24;
		if ($illa_day == 0) {
			if ($illa_month > 0 && $illa_month < 16) {
				$illa_day = 24;
			} else {
				$illa_day = 5;
			}
		} else {
			++$illa_month;
		}
		if ($illa_month == 0) {
			$illa_month = 16;
			--$illa_year;
		}

		$illa_hour = floor($time / 3600);
		$time -= $illa_hour * 3600;

		$illa_min = floor($time / 60);
		$time -= $illa_min * 60;

		if ($format == 'array') {
			return array('year' => $illa_year,
				'month' => $illa_month,
				'day' => $illa_day,
				'hour' => $illa_hour,
				'min' => $illa_min,
				'sec' => $time);
		}

		return strtr($format, array('a' => ($illa_hour < 12 ? 'am' : 'pm'),
				'A' => ($illa_hour < 12 ? 'AM' : 'PM'),
				'd' => ($illa_day < 10 ? '0' . $illa_day : $illa_day),
				'F' => self::getMonthName($illa_month),
				'g' => ($illa_hour > 12 ? $illa_hour - 12 : $illa_hour),
				'G' => $illa_hour,
				'h' => ($illa_hour < 10 ? '0' . $illa_hour : ($illa_hour < 13 ? $illa_hour : ($illa_hour < 22 ? '0' . $illa_hour - 12 : $illa_hour - 12))),
				'H' => ($illa_hour < 10 ? '0' . $illa_hour : $illa_hour),
				'i' => ($illa_min < 10 ? '0' . $illa_min : $illa_min),
				'j' => $illa_day,
				'm' => ($illa_month < 10 ? '0' . $illa_month : $illa_month),
				'M' => substr(self::getMonthName($illa_month), 0, 3),
				'n' => $illa_month,
				's' => ($time < 10 ? '0' . $time : $time),
				'S' => ($illa_day > 3 && $illa_day < 20 ? 'th' : ($illa_day % 10 == 1 ? 'st' : ($illa_day % 10 == 2 ? 'nd' : ($illa_day % 10 == 3 ? 'rd' : 'th')))),
				't' => ($illa_month == 16 ? 5 : 24),
				'U' => $copy_time,
				'Y' => $illa_year,
				'y' => $illa_year,
				'z' => $illa_day + (($illa_month - 1) * 24)));
	}
}

?>
